{"slug":"find-the-inverse-of-a","title":"Find the inverse of a","trackId":5271,"tags":["C++","Java","JavaScript","Python"],"contributors":["JoshuaT35","harshraj8843","cacti23","ShadyResurrected","anandfresh"],"contentHtml":"<h2>Write a program to find the inverse of a</h2>\n<p>The inverse of a square matrix A is another square matrix B such that the product of A and B is the identity matrix I. The inverse of A is denoted as A-1. Should address case where inverse does not exist.</p>\n<pre><code>Input  :\n1 2 3\n4 5 6\n7 8 9\n\nOutput :\n\"This matrix is not invertible\"\n\n\nInput  :\n1 -2 3\n4 5 2\n3 8 -2\n\nOutput :\n8.666666666666666 -6.666666666666667 6.333333333333333 \n-4.666666666666667 3.6666666666666665 -3.3333333333333335\n-5.666666666666667 4.666666666666667 -4.333333333333333\n</code></pre>\n<hr>\n<pre><code>#include &#x3C;iostream>\n\nusing namespace std;\n\nint main() {\n  int m[3][3];\n\n  cout &#x3C;&#x3C; \"Enter the elements of the matrix:\" &#x3C;&#x3C; endl;\n\n  for(int i = 0; i &#x3C; 3; i++) {\n    for(int j = 0; j &#x3C; 3; j++) {\n      cin >> m[i][j];\n    }\n  }\n\n  // intialize determinant\n  float d = 0;\n\n  //finding determinant of the matrix\n  for(int i = 0; i &#x3C; 3; i++) {\n    d = d + (m[0][i] * (m[1][(i+1)%3] * m[2][(i+2)%3] - m[1][(i+2)%3] * m[2][(i+1)%3]));\n  }\n  \n  if(d > 0) {\n    cout &#x3C;&#x3C; \"Inverse of this matrix is:\" &#x3C;&#x3C; endl;\n\n    for(int i = 0; i &#x3C; 3; i++) {\n      for(int j = 0; j &#x3C; 3; j++) {\n        cout &#x3C;&#x3C; ((m[(j+1)%3][(i+1)%3] * m[(j+2)%3][(i+2)%3]) - (m[(j+1)%3][(i+2)%3] * m[(j+2)%3][(i+1)%3]))/ d &#x3C;&#x3C;\"\\t\"; //finding adjoint and dividing it by determinant\n      }\n      cout &#x3C;&#x3C; endl;\n    }\n  } else {\n    cout &#x3C;&#x3C; \"Inverse does not exist for this matrix\" &#x3C;&#x3C; endl;\n  }\n\n  return 0;\n\n}\n</code></pre>\n<pre><code>import java.util.*;\n\npublic class FindTheInverseOfA {\n\n    public static double[][] inverse(double[][] matrix) {\n        int n = matrix.length;\n        double[][] inverse = new double[n][n];\n\n        // create the identity matrix\n        for (int i = 0; i &#x3C; n; i++) {\n            inverse[i][i] = 1;\n        }\n\n        // augment the matrix with the identity matrix\n        double[][] augmentedMatrix = new double[n][2 * n];\n        for (int i = 0; i &#x3C; n; i++) {\n            for (int j = 0; j &#x3C; n; j++) {\n                augmentedMatrix[i][j] = matrix[i][j];\n            }\n            for (int j = n; j &#x3C; 2 * n; j++) {\n                augmentedMatrix[i][j] = inverse[i][j - n];\n            }\n        }\n\n        // perform Gaussian elimination\n        for (int i = 0; i &#x3C; n; i++) {\n            double pivot = augmentedMatrix[i][i];\n            for (int j = i; j &#x3C; 2 * n; j++) {\n                augmentedMatrix[i][j] /= pivot;\n            }\n            for (int k = 0; k &#x3C; n; k++) {\n                if (k != i) {\n                    double factor = augmentedMatrix[k][i];\n                    for (int j = i; j &#x3C; 2 * n; j++) {\n                        augmentedMatrix[k][j] -= factor * augmentedMatrix[i][j];\n                    }\n                }\n            }\n        }\n\n        // extract the inverse from the augmented matrix\n        for (int i = 0; i &#x3C; n; i++) {\n            for (int j = n; j &#x3C; 2 * n; j++) {\n                inverse[i][j - n] = augmentedMatrix[i][j];\n            }\n        }\n\n        return inverse;\n    }\n\n    public static void main(String[] args) {\n        double[][] matrix = {{1,2,3},{4,5,6},{7,8,9}};\n        double[][] inverse = inverse(matrix);\n\n        for (int i = 0; i &#x3C; n; i++) {\n            for (int j = 0; j &#x3C; n; j++) {\n                System.out.print(inverse[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n</code></pre>\n<pre><code>// Functions:\n// returns the minor for every element in matrix\n// and applies cofactor sign to minor\nfunction minorAndSign(matrix, row, column)\n{\n    const detNums = [];\n    let detNumIdx = 0;\n    for (let i = 0; i &#x3C; 3; i++) {\n        for (let j = 0; j &#x3C; 3; j++) {\n            if ((i) != row &#x26;&#x26; (j) != column) {\n                detNums[detNumIdx] = matrix[i][j];\n                detNumIdx += 1;\n            }\n        }\n    }\n    // apply cofactor sign\n    if ((row+column) % 2 != 0) {\n        return (detNums[1]*detNums[2] - detNums[0]*detNums[3])\n    }\n    return (detNums[0]*detNums[3] - detNums[1]*detNums[2])\n}\n\n// print matrix\nfunction printMatrix(matrix) {\n    for (let row = 0; row &#x3C; 3; row++) {\n        console.log(matrix[row]);\n    }\n}\n\n// Main:\n// No html file, so set matrix values here\nconst matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]]\n\n// get determinant\nconst det = matrix[0][0]*minorAndSign(matrix, 0, 0)\n                + matrix[0][1]*minorAndSign(matrix, 0, 1)\n                + matrix[0][2]*minorAndSign(matrix, 0, 2)\n\nif (det === 0) {\n    console.log(\"Matrix is not invertible\");\n}\nelse {\n    // For each element:\n    //  get minor with cofactor sign\n    //  divide by determinant\n    //  put on other side of diagonal\n    const invMatrix = [[], [], []]\n    \n    for (let i = 0; i &#x3C; 3; i++) {\n        for (let j = 0; j &#x3C; 3; j++) {\n            let minor = minorAndSign(matrix, i, j);\n            invMatrix[j][i] = minor/det; // put on other side of diagonal\n        }\n    }\n    printMatrix(invMatrix);\n}\n</code></pre>\n<pre><code>import numpy as np\n\ninputArray = np.array([[4, 5, 1], [3, 4, 12], [10, 2, 1]])\n\nresultInverse = np.linalg.inv(inputArray)\n\nprint(resultInverse)\n</code></pre>\n","markdown":"\n## Write a program to find the inverse of a\n\nThe inverse of a square matrix A is another square matrix B such that the product of A and B is the identity matrix I. The inverse of A is denoted as A<sup>-1</sup>. Should address case where inverse does not exist.\n\n```txt\nInput  :\n1 2 3\n4 5 6\n7 8 9\n\nOutput :\n\"This matrix is not invertible\"\n\n\nInput  :\n1 -2 3\n4 5 2\n3 8 -2\n\nOutput :\n8.666666666666666 -6.666666666666667 6.333333333333333 \n-4.666666666666667 3.6666666666666665 -3.3333333333333335\n-5.666666666666667 4.666666666666667 -4.333333333333333\n```\n\n---\n\n<CodeBlock slug=\"find-the-inverse-of-a\" >\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n  int m[3][3];\n\n  cout << \"Enter the elements of the matrix:\" << endl;\n\n  for(int i = 0; i < 3; i++) {\n    for(int j = 0; j < 3; j++) {\n      cin >> m[i][j];\n    }\n  }\n\n  // intialize determinant\n  float d = 0;\n\n  //finding determinant of the matrix\n  for(int i = 0; i < 3; i++) {\n    d = d + (m[0][i] * (m[1][(i+1)%3] * m[2][(i+2)%3] - m[1][(i+2)%3] * m[2][(i+1)%3]));\n  }\n  \n  if(d > 0) {\n    cout << \"Inverse of this matrix is:\" << endl;\n\n    for(int i = 0; i < 3; i++) {\n      for(int j = 0; j < 3; j++) {\n        cout << ((m[(j+1)%3][(i+1)%3] * m[(j+2)%3][(i+2)%3]) - (m[(j+1)%3][(i+2)%3] * m[(j+2)%3][(i+1)%3]))/ d <<\"\\t\"; //finding adjoint and dividing it by determinant\n      }\n      cout << endl;\n    }\n  } else {\n    cout << \"Inverse does not exist for this matrix\" << endl;\n  }\n\n  return 0;\n\n}\n```\n\n```java\nimport java.util.*;\n\npublic class FindTheInverseOfA {\n\n    public static double[][] inverse(double[][] matrix) {\n        int n = matrix.length;\n        double[][] inverse = new double[n][n];\n\n        // create the identity matrix\n        for (int i = 0; i < n; i++) {\n            inverse[i][i] = 1;\n        }\n\n        // augment the matrix with the identity matrix\n        double[][] augmentedMatrix = new double[n][2 * n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                augmentedMatrix[i][j] = matrix[i][j];\n            }\n            for (int j = n; j < 2 * n; j++) {\n                augmentedMatrix[i][j] = inverse[i][j - n];\n            }\n        }\n\n        // perform Gaussian elimination\n        for (int i = 0; i < n; i++) {\n            double pivot = augmentedMatrix[i][i];\n            for (int j = i; j < 2 * n; j++) {\n                augmentedMatrix[i][j] /= pivot;\n            }\n            for (int k = 0; k < n; k++) {\n                if (k != i) {\n                    double factor = augmentedMatrix[k][i];\n                    for (int j = i; j < 2 * n; j++) {\n                        augmentedMatrix[k][j] -= factor * augmentedMatrix[i][j];\n                    }\n                }\n            }\n        }\n\n        // extract the inverse from the augmented matrix\n        for (int i = 0; i < n; i++) {\n            for (int j = n; j < 2 * n; j++) {\n                inverse[i][j - n] = augmentedMatrix[i][j];\n            }\n        }\n\n        return inverse;\n    }\n\n    public static void main(String[] args) {\n        double[][] matrix = {{1,2,3},{4,5,6},{7,8,9}};\n        double[][] inverse = inverse(matrix);\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                System.out.print(inverse[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n```\n\n```js\n// Functions:\n// returns the minor for every element in matrix\n// and applies cofactor sign to minor\nfunction minorAndSign(matrix, row, column)\n{\n    const detNums = [];\n    let detNumIdx = 0;\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            if ((i) != row && (j) != column) {\n                detNums[detNumIdx] = matrix[i][j];\n                detNumIdx += 1;\n            }\n        }\n    }\n    // apply cofactor sign\n    if ((row+column) % 2 != 0) {\n        return (detNums[1]*detNums[2] - detNums[0]*detNums[3])\n    }\n    return (detNums[0]*detNums[3] - detNums[1]*detNums[2])\n}\n\n// print matrix\nfunction printMatrix(matrix) {\n    for (let row = 0; row < 3; row++) {\n        console.log(matrix[row]);\n    }\n}\n\n// Main:\n// No html file, so set matrix values here\nconst matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]]\n\n// get determinant\nconst det = matrix[0][0]*minorAndSign(matrix, 0, 0)\n                + matrix[0][1]*minorAndSign(matrix, 0, 1)\n                + matrix[0][2]*minorAndSign(matrix, 0, 2)\n\nif (det === 0) {\n    console.log(\"Matrix is not invertible\");\n}\nelse {\n    // For each element:\n    //  get minor with cofactor sign\n    //  divide by determinant\n    //  put on other side of diagonal\n    const invMatrix = [[], [], []]\n    \n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            let minor = minorAndSign(matrix, i, j);\n            invMatrix[j][i] = minor/det; // put on other side of diagonal\n        }\n    }\n    printMatrix(invMatrix);\n}\n```\n\n```py\nimport numpy as np\n\ninputArray = np.array([[4, 5, 1], [3, 4, 12], [10, 2, 1]])\n\nresultInverse = np.linalg.inv(inputArray)\n\nprint(resultInverse)\n```\n\n</CodeBlock>\n\n","latestUpdateDate":"2023-02-28T04:54:55Z"}