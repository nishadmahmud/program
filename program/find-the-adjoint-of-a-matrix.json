{"slug":"find-the-adjoint-of-a-matrix","title":"Find the adjoint of a matrix","trackId":4037,"tags":["C++","Java","JavaScript","Python"],"contributors":["BoSaMo","harshraj8843","SarthakSanjay","aghiles-medane","joao-vitor-souza"],"contentHtml":"<h2>Write a program to find the adjoint of a matrix</h2>\n<p>The adjoint of a square matrix A is the transpose of the matrix of cofactors of A. The adjoint of a matrix A is denoted as A*.</p>\n<pre><code>Input  :\n1 2 3\n4 5 6\n7 8 9\n\nOutput :\n[[-3, 6, -3], [6, -12, 6], [-3, 6, -3]]\n</code></pre>\n<hr>\n<pre><code>#include &#x3C;cstddef>\n#include &#x3C;cmath>\n#include &#x3C;vector>\n#include &#x3C;initializer_list>\n\nclass Matrix\n{\n    std::vector&#x3C;int> m_data;\n    int m_size{};\n\npublic:\n    Matrix() = default;\n    Matrix(std::initializer_list&#x3C;int> l);\n\n    int determinant();\n    void set_elements(std::initializer_list&#x3C;int> l);\n    bool is_squared(int num);\n    Matrix adjoint();\n    int size() const { return m_size; }\n    Matrix get_submatrix(int i, int k) const;\n\n    int operator[](std::size_t idx) const { return (idx >= 0 &#x26;&#x26; idx &#x3C; m_data.size()) ? m_data.at(idx) : 0; }\n\nprivate:\n    void add_last(int element);\n};\n\nint Matrix::determinant()\n{\n    if (m_size == 1)\n    {\n        return m_data[0];\n    }\n    int sign, det = 0;\n    for (int r, c, i = 0; i &#x3C; m_data.size() / 2; i++)\n    {\n        r = static_cast&#x3C;int>(i / m_size);\n        c = i % m_size;\n        auto sub_matrix = get_submatrix(r, c);\n        sign = ((r + c) % 2 == 0) ? 1 : -1;\n        det += sign * m_data.at(i) * sub_matrix.determinant();\n    }\n    return det;\n}\n\nMatrix Matrix::get_submatrix(int r, int c) const\n{\n    Matrix m;\n    for (int i = 0; i &#x3C; m_data.size(); i++)\n    {\n        if (r == static_cast&#x3C;int>(i / m_size) || c == i % m_size)\n        {\n            continue;\n        }\n        m.add_last(m_data.at(i));\n    }\n    return m;\n}\n\nbool Matrix::is_squared(int num)\n{\n    auto sqrt_num = static_cast&#x3C;int>(std::sqrt(num));\n    return num == (sqrt_num * sqrt_num);\n}\n\nvoid Matrix::add_last(int element)\n{\n    m_data.push_back(element);\n    m_size = static_cast&#x3C;int>(std::sqrt(m_data.size()));\n}\n\nMatrix Matrix::adjoint()\n{\n    Matrix adjoint_matrix;\n\n    if (m_size == 1)\n    {\n        adjoint_matrix.set_elements({1});\n    }\n    for (int sign, c, r, i = 0; i &#x3C; m_data.size(); i++)\n    {\n        r = static_cast&#x3C;int>(i / m_size);\n        c = i % m_size;\n        auto sub_matrix = get_submatrix(r, c);\n        sign = ((r + c) % 2 == 0) ? 1 : -1;\n        adjoint_matrix.add_last(sign * sub_matrix.determinant());\n    }\n\n    return adjoint_matrix;\n}\n\nvoid Matrix::set_elements(std::initializer_list&#x3C;int> l)\n{\n    if (!is_squared(l.size()))\n    {\n        return;\n    }\n    m_data.insert(m_data.begin(), l);\n    m_size = std::sqrt(l.size());\n}\n</code></pre>\n<pre><code>public class Adjoints {\n\n\tstatic void getCofactors(int A[][], int temp[][], int p, int q, int n) {\n\t\tint i = 0, j = 0;\n\t\tfor (int row = 0; row &#x3C; n; row++) {\n\t\t\tfor (int col = 0; col &#x3C; n; col++) {\n\t\t\t\tif (row != p &#x26;&#x26; col != q) {\n\t\t\t\t\ttemp[i][j++] = A[row][col];\n\t\t\t\t\tif (j == n - 1) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int determinant(int A[][], int n) {\n\n\t\tif (n == 1)\n\t\t\treturn A[0][0];\n\t\tint N = A.length;\n\t\tint[][] tableTmp = new int[N][N];\n\t\tint D = 0;\n\t\t\n\t\tint sign = 1;\n\t\tfor (int f = 0; f &#x3C; n; f++) {\n\t\t\tgetCofactors(A, tableTmp, 0, f, n);\n\t\t\tD += sign * A[0][f] * determinant(tableTmp, n - 1);\n\t\t\tsign = -1 * sign;\n\t\t}\n\n\t\treturn D;\n\t}\n\n\tpublic static int[][] adjoint(int A[][]) {\n\n\t\tint N = A.length;\n\t\tint[][] adj = new int[N][N];\n\t\tif (N == 1) {\n\t\t\tadj[0][0] = 1;\n\t\t\treturn adj;\n\t\t}\n\n\t\tint sign = 1;\n\t\tint[][] temp = new int[N][N];\n\n\t\tfor (int i = 0; i &#x3C; N; i++) {\n\t\t\tfor (int j = 0; j &#x3C; N; j++) {\n\t\t\t\tgetCofactors(A, temp, i, j, N);\n\n\t\t\t\tsign = ((i + j) % 2 == 0) ? 1 : -1;\n\n\t\t\t\tadj[j][i] = (sign) * (determinant(temp, N - 1));\n\t\t\t}\n\t\t}\n\t\treturn adj;\n\t}\n\n}\n</code></pre>\n<pre><code>//simple function to find adj of matrix\nlet mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];\n\nfunction adjoint(matrix) {\nlet A00 = matrix[0][0];\nlet A01 = matrix[0][1];\nlet A02 = matrix[0][2];\nlet A10 = matrix[1][0];\nlet A11 = matrix[1][1];\nlet A12 = matrix[1][2];\nlet A20 = matrix[2][0];\nlet A21 = matrix[2][1];\nlet A22 = matrix[2][2];\n\nlet adj = [[(A11 * A22 - A12 * A21), -(A01 * A22 - A02 * A21), (A01 * A12 - A02 * A11)],\n[-(A10 * A22 - A12 * A20), (A00 * A22 - A02 * A20), -(A00 * A12 - A02 * A10)],\n[(A10 * A21 - A11 * A20), -(A00 * A21 - A01 * A20), (A00 * A11 - A01 * A10)]];\nreturn adj;\n}\n\nlet adjaointOfMatrix = adjoint(mat)\nconsole.log(adjaointOfMatrix)\n\n//adjoint of matrix using loop\n// function adjoint(matrix) {\n//     let adj = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n\n//     for (let i = 0; i &#x3C; 3; i++) {\n//         for (let j = 0; j &#x3C; 3; j++) {\n//             let a = (i + 1) % 3;\n//             let b = (j + 1) % 3;\n//             let c = (i + 2) % 3;\n//             let d = (j + 2) % 3;\n\n//             adj[j][i] = (matrix[a][b] * matrix[c][d] - matrix[a][d] * matrix[c][b]);\n//             if ((i + j) % 2 === 1) {\n//                 adj[j][i] = -adj[j][i];\n//             }\n//         }\n//     }\n\n//     return adj;\n// }\n</code></pre>\n<pre><code>from typing import List\nimport numpy as np\n\n\ndef compute_adjoint_matrix(matrix: List[List[int]]) -> np.ndarray:\n    n_lines = len(matrix)\n    n_columns = len(matrix[0])\n    cofactor_matrix = np.array([])\n    if n_lines != n_columns:\n        print(\"Input a square matrix!\")\n        return\n    for line in range(n_lines):\n        for column in range(n_columns):\n            minor_matrix = []\n            for minor_line in matrix:\n                minor_line_copy = minor_line.copy()\n                minor_line_copy.pop(column)\n                minor_matrix.append(minor_line_copy)\n            minor_matrix.pop(line)\n            cofactor_matrix = np.append(\n                cofactor_matrix, (-1) ** (line + column) * np.linalg.det(minor_matrix)\n            )\n\n    return cofactor_matrix.reshape((n_lines, n_columns)).T\n\n\nprint(compute_adjoint_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n\n\"\"\" Output:\n[[ -3.   6.  -3.]\n [  6. -12.   6.]\n [ -3.   6.  -3.]]\n\"\"\"\n</code></pre>\n","markdown":"\n## Write a program to find the adjoint of a matrix\n\nThe adjoint of a square matrix A is the transpose of the matrix of cofactors of A. The adjoint of a matrix A is denoted as A<sup>\\*</sup>.\n\n```txt\nInput  :\n1 2 3\n4 5 6\n7 8 9\n\nOutput :\n[[-3, 6, -3], [6, -12, 6], [-3, 6, -3]]\n```\n\n---\n\n<CodeBlock slug=\"find-the-adjoint-of-a-matrix\" >\n\n```cpp\n#include <cstddef>\n#include <cmath>\n#include <vector>\n#include <initializer_list>\n\nclass Matrix\n{\n    std::vector<int> m_data;\n    int m_size{};\n\npublic:\n    Matrix() = default;\n    Matrix(std::initializer_list<int> l);\n\n    int determinant();\n    void set_elements(std::initializer_list<int> l);\n    bool is_squared(int num);\n    Matrix adjoint();\n    int size() const { return m_size; }\n    Matrix get_submatrix(int i, int k) const;\n\n    int operator[](std::size_t idx) const { return (idx >= 0 && idx < m_data.size()) ? m_data.at(idx) : 0; }\n\nprivate:\n    void add_last(int element);\n};\n\nint Matrix::determinant()\n{\n    if (m_size == 1)\n    {\n        return m_data[0];\n    }\n    int sign, det = 0;\n    for (int r, c, i = 0; i < m_data.size() / 2; i++)\n    {\n        r = static_cast<int>(i / m_size);\n        c = i % m_size;\n        auto sub_matrix = get_submatrix(r, c);\n        sign = ((r + c) % 2 == 0) ? 1 : -1;\n        det += sign * m_data.at(i) * sub_matrix.determinant();\n    }\n    return det;\n}\n\nMatrix Matrix::get_submatrix(int r, int c) const\n{\n    Matrix m;\n    for (int i = 0; i < m_data.size(); i++)\n    {\n        if (r == static_cast<int>(i / m_size) || c == i % m_size)\n        {\n            continue;\n        }\n        m.add_last(m_data.at(i));\n    }\n    return m;\n}\n\nbool Matrix::is_squared(int num)\n{\n    auto sqrt_num = static_cast<int>(std::sqrt(num));\n    return num == (sqrt_num * sqrt_num);\n}\n\nvoid Matrix::add_last(int element)\n{\n    m_data.push_back(element);\n    m_size = static_cast<int>(std::sqrt(m_data.size()));\n}\n\nMatrix Matrix::adjoint()\n{\n    Matrix adjoint_matrix;\n\n    if (m_size == 1)\n    {\n        adjoint_matrix.set_elements({1});\n    }\n    for (int sign, c, r, i = 0; i < m_data.size(); i++)\n    {\n        r = static_cast<int>(i / m_size);\n        c = i % m_size;\n        auto sub_matrix = get_submatrix(r, c);\n        sign = ((r + c) % 2 == 0) ? 1 : -1;\n        adjoint_matrix.add_last(sign * sub_matrix.determinant());\n    }\n\n    return adjoint_matrix;\n}\n\nvoid Matrix::set_elements(std::initializer_list<int> l)\n{\n    if (!is_squared(l.size()))\n    {\n        return;\n    }\n    m_data.insert(m_data.begin(), l);\n    m_size = std::sqrt(l.size());\n}\n```\n\n```java\npublic class Adjoints {\n\n\tstatic void getCofactors(int A[][], int temp[][], int p, int q, int n) {\n\t\tint i = 0, j = 0;\n\t\tfor (int row = 0; row < n; row++) {\n\t\t\tfor (int col = 0; col < n; col++) {\n\t\t\t\tif (row != p && col != q) {\n\t\t\t\t\ttemp[i][j++] = A[row][col];\n\t\t\t\t\tif (j == n - 1) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int determinant(int A[][], int n) {\n\n\t\tif (n == 1)\n\t\t\treturn A[0][0];\n\t\tint N = A.length;\n\t\tint[][] tableTmp = new int[N][N];\n\t\tint D = 0;\n\t\t\n\t\tint sign = 1;\n\t\tfor (int f = 0; f < n; f++) {\n\t\t\tgetCofactors(A, tableTmp, 0, f, n);\n\t\t\tD += sign * A[0][f] * determinant(tableTmp, n - 1);\n\t\t\tsign = -1 * sign;\n\t\t}\n\n\t\treturn D;\n\t}\n\n\tpublic static int[][] adjoint(int A[][]) {\n\n\t\tint N = A.length;\n\t\tint[][] adj = new int[N][N];\n\t\tif (N == 1) {\n\t\t\tadj[0][0] = 1;\n\t\t\treturn adj;\n\t\t}\n\n\t\tint sign = 1;\n\t\tint[][] temp = new int[N][N];\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tgetCofactors(A, temp, i, j, N);\n\n\t\t\t\tsign = ((i + j) % 2 == 0) ? 1 : -1;\n\n\t\t\t\tadj[j][i] = (sign) * (determinant(temp, N - 1));\n\t\t\t}\n\t\t}\n\t\treturn adj;\n\t}\n\n}\n```\n\n```js\n//simple function to find adj of matrix\nlet mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];\n\nfunction adjoint(matrix) {\nlet A00 = matrix[0][0];\nlet A01 = matrix[0][1];\nlet A02 = matrix[0][2];\nlet A10 = matrix[1][0];\nlet A11 = matrix[1][1];\nlet A12 = matrix[1][2];\nlet A20 = matrix[2][0];\nlet A21 = matrix[2][1];\nlet A22 = matrix[2][2];\n\nlet adj = [[(A11 * A22 - A12 * A21), -(A01 * A22 - A02 * A21), (A01 * A12 - A02 * A11)],\n[-(A10 * A22 - A12 * A20), (A00 * A22 - A02 * A20), -(A00 * A12 - A02 * A10)],\n[(A10 * A21 - A11 * A20), -(A00 * A21 - A01 * A20), (A00 * A11 - A01 * A10)]];\nreturn adj;\n}\n\nlet adjaointOfMatrix = adjoint(mat)\nconsole.log(adjaointOfMatrix)\n\n//adjoint of matrix using loop\n// function adjoint(matrix) {\n//     let adj = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n\n//     for (let i = 0; i < 3; i++) {\n//         for (let j = 0; j < 3; j++) {\n//             let a = (i + 1) % 3;\n//             let b = (j + 1) % 3;\n//             let c = (i + 2) % 3;\n//             let d = (j + 2) % 3;\n\n//             adj[j][i] = (matrix[a][b] * matrix[c][d] - matrix[a][d] * matrix[c][b]);\n//             if ((i + j) % 2 === 1) {\n//                 adj[j][i] = -adj[j][i];\n//             }\n//         }\n//     }\n\n//     return adj;\n// }\n```\n\n```py\nfrom typing import List\nimport numpy as np\n\n\ndef compute_adjoint_matrix(matrix: List[List[int]]) -> np.ndarray:\n    n_lines = len(matrix)\n    n_columns = len(matrix[0])\n    cofactor_matrix = np.array([])\n    if n_lines != n_columns:\n        print(\"Input a square matrix!\")\n        return\n    for line in range(n_lines):\n        for column in range(n_columns):\n            minor_matrix = []\n            for minor_line in matrix:\n                minor_line_copy = minor_line.copy()\n                minor_line_copy.pop(column)\n                minor_matrix.append(minor_line_copy)\n            minor_matrix.pop(line)\n            cofactor_matrix = np.append(\n                cofactor_matrix, (-1) ** (line + column) * np.linalg.det(minor_matrix)\n            )\n\n    return cofactor_matrix.reshape((n_lines, n_columns)).T\n\n\nprint(compute_adjoint_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n\n\"\"\" Output:\n[[ -3.   6.  -3.]\n [  6. -12.   6.]\n [ -3.   6.  -3.]]\n\"\"\"\n```\n\n</CodeBlock>\n\n","latestUpdateDate":"2023-03-03T17:20:04Z"}